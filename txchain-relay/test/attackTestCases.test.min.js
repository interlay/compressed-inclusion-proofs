const e=artifacts.require("./BrokenRelay.sol"),a=artifacts.require("./Utils.sol"),t=require("./constants"),i=require("./helpers"),r=require("truffle-assertions"),c=require("./testdata/blocks.json");var l=i.dblSha256Flip,s=i.flipBytes;contract("Attack Test Cases",async i=>{const l=async function(){genesis=c[0],await relay.setInitialParent(genesis.header,genesis.height)};beforeEach("(re)deploy contracts",(async function(){relay=await e.new(),utils=await a.deployed()})),it("TESTCASE 1: set duplicate initial parent - should fail",async()=>{l(),await r.reverts(relay.setInitialParent(genesis.header,genesis.height))}),it("TESTCASE 2: duplicate block submission - should fail",async()=>{l(),block1=c[1];let e=await relay.submitBlockHeader(block1.header);r.eventEmitted(e,"StoreHeader",e=>e.blockHeight==block1.height)}),it("TESTCASE 3a: too large block header - should fail",async()=>{l(),block1=c[1],await r.reverts(relay.submitBlockHeader(block1.header+"123"),t.ERROR_CODES.ERR_INVALID_HEADER)}),it("TESTCASE 3b: too small block header - should fail",async()=>{l(),block1=c[1],await r.reverts(relay.submitBlockHeader(block1.header.substring(0,28)),t.ERROR_CODES.ERR_INVALID_HEADER)}),it("TESTCASE 4: submit block where prev block is not in main chain - should fail",async()=>{l(),block2=c[2],await r.reverts(relay.submitBlockHeader(block2.header),t.ERROR_CODES.ERR_PREV_BLOCK)}),it("TESTCASE 5: weak block submission - should fail",async()=>{fakeGenesis={hash:"0x00000000000000000012af6694accf510ca4a979824f30f362d387821564ca93",height:597613,merkleroot:"0x1c7b7ac77c221e1c0410eca20c002fa7b6467ba966d700868928dae4693b3b78",header:"0x00000020614db6ddb63ec3a51555336aed1fa4b86e8cc52e01900e000000000000000000783b3b69e4da28898600d766a97b46b6a72f000ca2ec10041c1e227cc77a7b1c6a43955d240f1617cb069aed"},fakeBlock={hash:"0x000000000000000000050db24a549b7b9dbbc9de1f44cd94e82cc6863b4f4fc0",height:597614,merkleroot:"0xc090099a4b0b7245724be6c7d58a64e0bd7718866a5afa81aa3e63ffa8acd69d",header:"0x0000002093ca64158287d362f3304f8279a9a40c51cfac9466af120000000000000000009dd6aca8ff633eaa81fa5a6a861877bde0648ad5c7e64b7245720b4b9a0990c07745955d240f16171c168c88"},await relay.setInitialParent(fakeGenesis.header,fakeGenesis.height),await r.reverts(relay.submitBlockHeader(fakeBlock.header),t.ERROR_CODES.ERR_LOW_DIFF)}),it("TESTCASE 6: empty txid - should fail",async()=>{l(),block1=c[1];let e=await relay.submitBlockHeader(block1.header);r.eventEmitted(e,"StoreHeader",e=>e.blockHeight==block1.height),tx=block1.tx[0],await r.reverts(relay.verifyTx("0x0000000000000000000000000000000000000000000000000000000000000000",block1.height,tx.tx_index,tx.merklePath,0),t.ERR_INVALID_TXID)}),it("TESTCASE 7: wrong txid parsed for verification - should fail!",async()=>{l(),block1=c[1];let e=await relay.submitBlockHeader(block1.header);r.eventEmitted(e,"StoreHeader",e=>e.blockHeight==block1.height),tx=block1.tx[0],fakeMerkle=await r.reverts(relay.verifyTx("0x1111111111111111111111111111111111111111111111111111111111111111",block1.height,tx.tx_index,tx.merklePath,0),t.ERR_INVALID_TXID)}),it("TESTCASE 8: missing tx confirmation check - should fail",async()=>{l(),block1=c[1];let e=await relay.submitBlockHeader(block1.header);r.eventEmitted(e,"StoreHeader",e=>e.blockHeight==block1.height),confirmations=10,c.slice(2,4).forEach(e=>{relay.submitBlockHeader(e.header)}),tx=block1.tx[0],await r.reverts(relay.verifyTx(tx.tx_id,block1.height,tx.tx_index,tx.merklePath,confirmations),t.ERR_CONFIRMS)}),it("TESTCASE 9: performance: instantly return if only 1 hash - save costs!",async()=>{l(),block1=c[1];let e=await relay.submitBlockHeader(block1.header);r.eventEmitted(e,"StoreHeader",e=>e.blockHeight==block1.height),tx=block1.tx[0],verifyTx=await relay.verifyTx(tx.tx_id,block1.height,tx.tx_index,tx.merklePath,0),assert(verifyTx.receipt.gasUsed<48440)})});